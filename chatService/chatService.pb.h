// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: chatService.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_chatService_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_chatService_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_chatService_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_chatService_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_chatService_2eproto;
namespace chatservice {
class ChatMessage;
struct ChatMessageDefaultTypeInternal;
extern ChatMessageDefaultTypeInternal _ChatMessage_default_instance_;
class CreateAccountMessage;
struct CreateAccountMessageDefaultTypeInternal;
extern CreateAccountMessageDefaultTypeInternal _CreateAccountMessage_default_instance_;
class CreateAccountReply;
struct CreateAccountReplyDefaultTypeInternal;
extern CreateAccountReplyDefaultTypeInternal _CreateAccountReply_default_instance_;
class DeleteAccountMessage;
struct DeleteAccountMessageDefaultTypeInternal;
extern DeleteAccountMessageDefaultTypeInternal _DeleteAccountMessage_default_instance_;
class DeleteAccountReply;
struct DeleteAccountReplyDefaultTypeInternal;
extern DeleteAccountReplyDefaultTypeInternal _DeleteAccountReply_default_instance_;
class LoginMessage;
struct LoginMessageDefaultTypeInternal;
extern LoginMessageDefaultTypeInternal _LoginMessage_default_instance_;
class LoginReply;
struct LoginReplyDefaultTypeInternal;
extern LoginReplyDefaultTypeInternal _LoginReply_default_instance_;
class LogoutMessage;
struct LogoutMessageDefaultTypeInternal;
extern LogoutMessageDefaultTypeInternal _LogoutMessage_default_instance_;
class LogoutReply;
struct LogoutReplyDefaultTypeInternal;
extern LogoutReplyDefaultTypeInternal _LogoutReply_default_instance_;
class MessagesSeenMessage;
struct MessagesSeenMessageDefaultTypeInternal;
extern MessagesSeenMessageDefaultTypeInternal _MessagesSeenMessage_default_instance_;
class NewMessageReply;
struct NewMessageReplyDefaultTypeInternal;
extern NewMessageReplyDefaultTypeInternal _NewMessageReply_default_instance_;
class Notification;
struct NotificationDefaultTypeInternal;
extern NotificationDefaultTypeInternal _Notification_default_instance_;
class QueryMessagesMessage;
struct QueryMessagesMessageDefaultTypeInternal;
extern QueryMessagesMessageDefaultTypeInternal _QueryMessagesMessage_default_instance_;
class QueryNotificationsMessage;
struct QueryNotificationsMessageDefaultTypeInternal;
extern QueryNotificationsMessageDefaultTypeInternal _QueryNotificationsMessage_default_instance_;
class QueryUsersMessage;
struct QueryUsersMessageDefaultTypeInternal;
extern QueryUsersMessageDefaultTypeInternal _QueryUsersMessage_default_instance_;
class RefreshRequest;
struct RefreshRequestDefaultTypeInternal;
extern RefreshRequestDefaultTypeInternal _RefreshRequest_default_instance_;
class RefreshResponse;
struct RefreshResponseDefaultTypeInternal;
extern RefreshResponseDefaultTypeInternal _RefreshResponse_default_instance_;
class SendMessageReply;
struct SendMessageReplyDefaultTypeInternal;
extern SendMessageReplyDefaultTypeInternal _SendMessageReply_default_instance_;
class User;
struct UserDefaultTypeInternal;
extern UserDefaultTypeInternal _User_default_instance_;
}  // namespace chatservice
PROTOBUF_NAMESPACE_OPEN
template<> ::chatservice::ChatMessage* Arena::CreateMaybeMessage<::chatservice::ChatMessage>(Arena*);
template<> ::chatservice::CreateAccountMessage* Arena::CreateMaybeMessage<::chatservice::CreateAccountMessage>(Arena*);
template<> ::chatservice::CreateAccountReply* Arena::CreateMaybeMessage<::chatservice::CreateAccountReply>(Arena*);
template<> ::chatservice::DeleteAccountMessage* Arena::CreateMaybeMessage<::chatservice::DeleteAccountMessage>(Arena*);
template<> ::chatservice::DeleteAccountReply* Arena::CreateMaybeMessage<::chatservice::DeleteAccountReply>(Arena*);
template<> ::chatservice::LoginMessage* Arena::CreateMaybeMessage<::chatservice::LoginMessage>(Arena*);
template<> ::chatservice::LoginReply* Arena::CreateMaybeMessage<::chatservice::LoginReply>(Arena*);
template<> ::chatservice::LogoutMessage* Arena::CreateMaybeMessage<::chatservice::LogoutMessage>(Arena*);
template<> ::chatservice::LogoutReply* Arena::CreateMaybeMessage<::chatservice::LogoutReply>(Arena*);
template<> ::chatservice::MessagesSeenMessage* Arena::CreateMaybeMessage<::chatservice::MessagesSeenMessage>(Arena*);
template<> ::chatservice::NewMessageReply* Arena::CreateMaybeMessage<::chatservice::NewMessageReply>(Arena*);
template<> ::chatservice::Notification* Arena::CreateMaybeMessage<::chatservice::Notification>(Arena*);
template<> ::chatservice::QueryMessagesMessage* Arena::CreateMaybeMessage<::chatservice::QueryMessagesMessage>(Arena*);
template<> ::chatservice::QueryNotificationsMessage* Arena::CreateMaybeMessage<::chatservice::QueryNotificationsMessage>(Arena*);
template<> ::chatservice::QueryUsersMessage* Arena::CreateMaybeMessage<::chatservice::QueryUsersMessage>(Arena*);
template<> ::chatservice::RefreshRequest* Arena::CreateMaybeMessage<::chatservice::RefreshRequest>(Arena*);
template<> ::chatservice::RefreshResponse* Arena::CreateMaybeMessage<::chatservice::RefreshResponse>(Arena*);
template<> ::chatservice::SendMessageReply* Arena::CreateMaybeMessage<::chatservice::SendMessageReply>(Arena*);
template<> ::chatservice::User* Arena::CreateMaybeMessage<::chatservice::User>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace chatservice {

// ===================================================================

class CreateAccountMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatservice.CreateAccountMessage) */ {
 public:
  inline CreateAccountMessage() : CreateAccountMessage(nullptr) {}
  ~CreateAccountMessage() override;
  explicit PROTOBUF_CONSTEXPR CreateAccountMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateAccountMessage(const CreateAccountMessage& from);
  CreateAccountMessage(CreateAccountMessage&& from) noexcept
    : CreateAccountMessage() {
    *this = ::std::move(from);
  }

  inline CreateAccountMessage& operator=(const CreateAccountMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateAccountMessage& operator=(CreateAccountMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateAccountMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateAccountMessage* internal_default_instance() {
    return reinterpret_cast<const CreateAccountMessage*>(
               &_CreateAccountMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CreateAccountMessage& a, CreateAccountMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateAccountMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateAccountMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateAccountMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateAccountMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateAccountMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateAccountMessage& from) {
    CreateAccountMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateAccountMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatservice.CreateAccountMessage";
  }
  protected:
  explicit CreateAccountMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:chatservice.CreateAccountMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class CreateAccountReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatservice.CreateAccountReply) */ {
 public:
  inline CreateAccountReply() : CreateAccountReply(nullptr) {}
  ~CreateAccountReply() override;
  explicit PROTOBUF_CONSTEXPR CreateAccountReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateAccountReply(const CreateAccountReply& from);
  CreateAccountReply(CreateAccountReply&& from) noexcept
    : CreateAccountReply() {
    *this = ::std::move(from);
  }

  inline CreateAccountReply& operator=(const CreateAccountReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateAccountReply& operator=(CreateAccountReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateAccountReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateAccountReply* internal_default_instance() {
    return reinterpret_cast<const CreateAccountReply*>(
               &_CreateAccountReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CreateAccountReply& a, CreateAccountReply& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateAccountReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateAccountReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateAccountReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateAccountReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateAccountReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateAccountReply& from) {
    CreateAccountReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateAccountReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatservice.CreateAccountReply";
  }
  protected:
  explicit CreateAccountReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMsgFieldNumber = 2,
    kCreateAccountSuccessFieldNumber = 1,
  };
  // optional string errorMsg = 2;
  bool has_errormsg() const;
  private:
  bool _internal_has_errormsg() const;
  public:
  void clear_errormsg();
  const std::string& errormsg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_errormsg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_errormsg();
  PROTOBUF_NODISCARD std::string* release_errormsg();
  void set_allocated_errormsg(std::string* errormsg);
  private:
  const std::string& _internal_errormsg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errormsg(const std::string& value);
  std::string* _internal_mutable_errormsg();
  public:

  // bool createAccountSuccess = 1;
  void clear_createaccountsuccess();
  bool createaccountsuccess() const;
  void set_createaccountsuccess(bool value);
  private:
  bool _internal_createaccountsuccess() const;
  void _internal_set_createaccountsuccess(bool value);
  public:

  // @@protoc_insertion_point(class_scope:chatservice.CreateAccountReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errormsg_;
    bool createaccountsuccess_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class LoginMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatservice.LoginMessage) */ {
 public:
  inline LoginMessage() : LoginMessage(nullptr) {}
  ~LoginMessage() override;
  explicit PROTOBUF_CONSTEXPR LoginMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginMessage(const LoginMessage& from);
  LoginMessage(LoginMessage&& from) noexcept
    : LoginMessage() {
    *this = ::std::move(from);
  }

  inline LoginMessage& operator=(const LoginMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginMessage& operator=(LoginMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginMessage* internal_default_instance() {
    return reinterpret_cast<const LoginMessage*>(
               &_LoginMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(LoginMessage& a, LoginMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginMessage& from) {
    LoginMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatservice.LoginMessage";
  }
  protected:
  explicit LoginMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:chatservice.LoginMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class LoginReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatservice.LoginReply) */ {
 public:
  inline LoginReply() : LoginReply(nullptr) {}
  ~LoginReply() override;
  explicit PROTOBUF_CONSTEXPR LoginReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginReply(const LoginReply& from);
  LoginReply(LoginReply&& from) noexcept
    : LoginReply() {
    *this = ::std::move(from);
  }

  inline LoginReply& operator=(const LoginReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginReply& operator=(LoginReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginReply* internal_default_instance() {
    return reinterpret_cast<const LoginReply*>(
               &_LoginReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(LoginReply& a, LoginReply& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginReply& from) {
    LoginReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatservice.LoginReply";
  }
  protected:
  explicit LoginReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMsgFieldNumber = 2,
    kLoginSuccessFieldNumber = 1,
  };
  // optional string errorMsg = 2;
  bool has_errormsg() const;
  private:
  bool _internal_has_errormsg() const;
  public:
  void clear_errormsg();
  const std::string& errormsg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_errormsg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_errormsg();
  PROTOBUF_NODISCARD std::string* release_errormsg();
  void set_allocated_errormsg(std::string* errormsg);
  private:
  const std::string& _internal_errormsg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errormsg(const std::string& value);
  std::string* _internal_mutable_errormsg();
  public:

  // bool loginSuccess = 1;
  void clear_loginsuccess();
  bool loginsuccess() const;
  void set_loginsuccess(bool value);
  private:
  bool _internal_loginsuccess() const;
  void _internal_set_loginsuccess(bool value);
  public:

  // @@protoc_insertion_point(class_scope:chatservice.LoginReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errormsg_;
    bool loginsuccess_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class LogoutMessage final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:chatservice.LogoutMessage) */ {
 public:
  inline LogoutMessage() : LogoutMessage(nullptr) {}
  explicit PROTOBUF_CONSTEXPR LogoutMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogoutMessage(const LogoutMessage& from);
  LogoutMessage(LogoutMessage&& from) noexcept
    : LogoutMessage() {
    *this = ::std::move(from);
  }

  inline LogoutMessage& operator=(const LogoutMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogoutMessage& operator=(LogoutMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogoutMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogoutMessage* internal_default_instance() {
    return reinterpret_cast<const LogoutMessage*>(
               &_LogoutMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(LogoutMessage& a, LogoutMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(LogoutMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogoutMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogoutMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogoutMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const LogoutMessage& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const LogoutMessage& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatservice.LogoutMessage";
  }
  protected:
  explicit LogoutMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:chatservice.LogoutMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class LogoutReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatservice.LogoutReply) */ {
 public:
  inline LogoutReply() : LogoutReply(nullptr) {}
  ~LogoutReply() override;
  explicit PROTOBUF_CONSTEXPR LogoutReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogoutReply(const LogoutReply& from);
  LogoutReply(LogoutReply&& from) noexcept
    : LogoutReply() {
    *this = ::std::move(from);
  }

  inline LogoutReply& operator=(const LogoutReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogoutReply& operator=(LogoutReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogoutReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogoutReply* internal_default_instance() {
    return reinterpret_cast<const LogoutReply*>(
               &_LogoutReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(LogoutReply& a, LogoutReply& b) {
    a.Swap(&b);
  }
  inline void Swap(LogoutReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogoutReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogoutReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogoutReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogoutReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LogoutReply& from) {
    LogoutReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogoutReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatservice.LogoutReply";
  }
  protected:
  explicit LogoutReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMsgFieldNumber = 2,
  };
  // optional string errorMsg = 2;
  bool has_errormsg() const;
  private:
  bool _internal_has_errormsg() const;
  public:
  void clear_errormsg();
  const std::string& errormsg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_errormsg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_errormsg();
  PROTOBUF_NODISCARD std::string* release_errormsg();
  void set_allocated_errormsg(std::string* errormsg);
  private:
  const std::string& _internal_errormsg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errormsg(const std::string& value);
  std::string* _internal_mutable_errormsg();
  public:

  // @@protoc_insertion_point(class_scope:chatservice.LogoutReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errormsg_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class QueryUsersMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatservice.QueryUsersMessage) */ {
 public:
  inline QueryUsersMessage() : QueryUsersMessage(nullptr) {}
  ~QueryUsersMessage() override;
  explicit PROTOBUF_CONSTEXPR QueryUsersMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryUsersMessage(const QueryUsersMessage& from);
  QueryUsersMessage(QueryUsersMessage&& from) noexcept
    : QueryUsersMessage() {
    *this = ::std::move(from);
  }

  inline QueryUsersMessage& operator=(const QueryUsersMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryUsersMessage& operator=(QueryUsersMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryUsersMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryUsersMessage* internal_default_instance() {
    return reinterpret_cast<const QueryUsersMessage*>(
               &_QueryUsersMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(QueryUsersMessage& a, QueryUsersMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryUsersMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryUsersMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryUsersMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryUsersMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryUsersMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryUsersMessage& from) {
    QueryUsersMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryUsersMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatservice.QueryUsersMessage";
  }
  protected:
  explicit QueryUsersMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
  };
  // optional string username = 1;
  bool has_username() const;
  private:
  bool _internal_has_username() const;
  public:
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // @@protoc_insertion_point(class_scope:chatservice.QueryUsersMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class User final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatservice.User) */ {
 public:
  inline User() : User(nullptr) {}
  ~User() override;
  explicit PROTOBUF_CONSTEXPR User(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  User(const User& from);
  User(User&& from) noexcept
    : User() {
    *this = ::std::move(from);
  }

  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }
  inline User& operator=(User&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const User& default_instance() {
    return *internal_default_instance();
  }
  static inline const User* internal_default_instance() {
    return reinterpret_cast<const User*>(
               &_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(User& a, User& b) {
    a.Swap(&b);
  }
  inline void Swap(User* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(User* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  User* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<User>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const User& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const User& from) {
    User::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(User* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatservice.User";
  }
  protected:
  explicit User(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // @@protoc_insertion_point(class_scope:chatservice.User)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class SendMessageReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatservice.SendMessageReply) */ {
 public:
  inline SendMessageReply() : SendMessageReply(nullptr) {}
  ~SendMessageReply() override;
  explicit PROTOBUF_CONSTEXPR SendMessageReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendMessageReply(const SendMessageReply& from);
  SendMessageReply(SendMessageReply&& from) noexcept
    : SendMessageReply() {
    *this = ::std::move(from);
  }

  inline SendMessageReply& operator=(const SendMessageReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendMessageReply& operator=(SendMessageReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendMessageReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendMessageReply* internal_default_instance() {
    return reinterpret_cast<const SendMessageReply*>(
               &_SendMessageReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SendMessageReply& a, SendMessageReply& b) {
    a.Swap(&b);
  }
  inline void Swap(SendMessageReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendMessageReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendMessageReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendMessageReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendMessageReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SendMessageReply& from) {
    SendMessageReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendMessageReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatservice.SendMessageReply";
  }
  protected:
  explicit SendMessageReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMsgFieldNumber = 2,
    kMessageSentFieldNumber = 1,
  };
  // optional string errorMsg = 2;
  bool has_errormsg() const;
  private:
  bool _internal_has_errormsg() const;
  public:
  void clear_errormsg();
  const std::string& errormsg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_errormsg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_errormsg();
  PROTOBUF_NODISCARD std::string* release_errormsg();
  void set_allocated_errormsg(std::string* errormsg);
  private:
  const std::string& _internal_errormsg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errormsg(const std::string& value);
  std::string* _internal_mutable_errormsg();
  public:

  // bool messageSent = 1;
  void clear_messagesent();
  bool messagesent() const;
  void set_messagesent(bool value);
  private:
  bool _internal_messagesent() const;
  void _internal_set_messagesent(bool value);
  public:

  // @@protoc_insertion_point(class_scope:chatservice.SendMessageReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errormsg_;
    bool messagesent_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class QueryNotificationsMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatservice.QueryNotificationsMessage) */ {
 public:
  inline QueryNotificationsMessage() : QueryNotificationsMessage(nullptr) {}
  ~QueryNotificationsMessage() override;
  explicit PROTOBUF_CONSTEXPR QueryNotificationsMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryNotificationsMessage(const QueryNotificationsMessage& from);
  QueryNotificationsMessage(QueryNotificationsMessage&& from) noexcept
    : QueryNotificationsMessage() {
    *this = ::std::move(from);
  }

  inline QueryNotificationsMessage& operator=(const QueryNotificationsMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryNotificationsMessage& operator=(QueryNotificationsMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryNotificationsMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryNotificationsMessage* internal_default_instance() {
    return reinterpret_cast<const QueryNotificationsMessage*>(
               &_QueryNotificationsMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(QueryNotificationsMessage& a, QueryNotificationsMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryNotificationsMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryNotificationsMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryNotificationsMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryNotificationsMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryNotificationsMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryNotificationsMessage& from) {
    QueryNotificationsMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryNotificationsMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatservice.QueryNotificationsMessage";
  }
  protected:
  explicit QueryNotificationsMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
  };
  // string user = 1;
  void clear_user();
  const std::string& user() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user();
  PROTOBUF_NODISCARD std::string* release_user();
  void set_allocated_user(std::string* user);
  private:
  const std::string& _internal_user() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user(const std::string& value);
  std::string* _internal_mutable_user();
  public:

  // @@protoc_insertion_point(class_scope:chatservice.QueryNotificationsMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class Notification final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatservice.Notification) */ {
 public:
  inline Notification() : Notification(nullptr) {}
  ~Notification() override;
  explicit PROTOBUF_CONSTEXPR Notification(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Notification(const Notification& from);
  Notification(Notification&& from) noexcept
    : Notification() {
    *this = ::std::move(from);
  }

  inline Notification& operator=(const Notification& from) {
    CopyFrom(from);
    return *this;
  }
  inline Notification& operator=(Notification&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Notification& default_instance() {
    return *internal_default_instance();
  }
  static inline const Notification* internal_default_instance() {
    return reinterpret_cast<const Notification*>(
               &_Notification_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Notification& a, Notification& b) {
    a.Swap(&b);
  }
  inline void Swap(Notification* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Notification* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Notification* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Notification>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Notification& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Notification& from) {
    Notification::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Notification* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatservice.Notification";
  }
  protected:
  explicit Notification(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
    kNumberOfNotificationsFieldNumber = 2,
  };
  // string user = 1;
  void clear_user();
  const std::string& user() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user();
  PROTOBUF_NODISCARD std::string* release_user();
  void set_allocated_user(std::string* user);
  private:
  const std::string& _internal_user() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user(const std::string& value);
  std::string* _internal_mutable_user();
  public:

  // int32 numberOfNotifications = 2;
  void clear_numberofnotifications();
  int32_t numberofnotifications() const;
  void set_numberofnotifications(int32_t value);
  private:
  int32_t _internal_numberofnotifications() const;
  void _internal_set_numberofnotifications(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:chatservice.Notification)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_;
    int32_t numberofnotifications_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class QueryMessagesMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatservice.QueryMessagesMessage) */ {
 public:
  inline QueryMessagesMessage() : QueryMessagesMessage(nullptr) {}
  ~QueryMessagesMessage() override;
  explicit PROTOBUF_CONSTEXPR QueryMessagesMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryMessagesMessage(const QueryMessagesMessage& from);
  QueryMessagesMessage(QueryMessagesMessage&& from) noexcept
    : QueryMessagesMessage() {
    *this = ::std::move(from);
  }

  inline QueryMessagesMessage& operator=(const QueryMessagesMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryMessagesMessage& operator=(QueryMessagesMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryMessagesMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryMessagesMessage* internal_default_instance() {
    return reinterpret_cast<const QueryMessagesMessage*>(
               &_QueryMessagesMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(QueryMessagesMessage& a, QueryMessagesMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryMessagesMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryMessagesMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryMessagesMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryMessagesMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryMessagesMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryMessagesMessage& from) {
    QueryMessagesMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryMessagesMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatservice.QueryMessagesMessage";
  }
  protected:
  explicit QueryMessagesMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientUsernameFieldNumber = 1,
    kOtherUsernameFieldNumber = 2,
  };
  // string clientUsername = 1;
  void clear_clientusername();
  const std::string& clientusername() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientusername(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientusername();
  PROTOBUF_NODISCARD std::string* release_clientusername();
  void set_allocated_clientusername(std::string* clientusername);
  private:
  const std::string& _internal_clientusername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientusername(const std::string& value);
  std::string* _internal_mutable_clientusername();
  public:

  // string otherUsername = 2;
  void clear_otherusername();
  const std::string& otherusername() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_otherusername(ArgT0&& arg0, ArgT... args);
  std::string* mutable_otherusername();
  PROTOBUF_NODISCARD std::string* release_otherusername();
  void set_allocated_otherusername(std::string* otherusername);
  private:
  const std::string& _internal_otherusername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_otherusername(const std::string& value);
  std::string* _internal_mutable_otherusername();
  public:

  // @@protoc_insertion_point(class_scope:chatservice.QueryMessagesMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientusername_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr otherusername_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class ChatMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatservice.ChatMessage) */ {
 public:
  inline ChatMessage() : ChatMessage(nullptr) {}
  ~ChatMessage() override;
  explicit PROTOBUF_CONSTEXPR ChatMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChatMessage(const ChatMessage& from);
  ChatMessage(ChatMessage&& from) noexcept
    : ChatMessage() {
    *this = ::std::move(from);
  }

  inline ChatMessage& operator=(const ChatMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatMessage& operator=(ChatMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatMessage* internal_default_instance() {
    return reinterpret_cast<const ChatMessage*>(
               &_ChatMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ChatMessage& a, ChatMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChatMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChatMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChatMessage& from) {
    ChatMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChatMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatservice.ChatMessage";
  }
  protected:
  explicit ChatMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderUsernameFieldNumber = 1,
    kRecipientUsernameFieldNumber = 2,
    kMsgContentFieldNumber = 3,
  };
  // string senderUsername = 1;
  void clear_senderusername();
  const std::string& senderusername() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_senderusername(ArgT0&& arg0, ArgT... args);
  std::string* mutable_senderusername();
  PROTOBUF_NODISCARD std::string* release_senderusername();
  void set_allocated_senderusername(std::string* senderusername);
  private:
  const std::string& _internal_senderusername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_senderusername(const std::string& value);
  std::string* _internal_mutable_senderusername();
  public:

  // string recipientUsername = 2;
  void clear_recipientusername();
  const std::string& recipientusername() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_recipientusername(ArgT0&& arg0, ArgT... args);
  std::string* mutable_recipientusername();
  PROTOBUF_NODISCARD std::string* release_recipientusername();
  void set_allocated_recipientusername(std::string* recipientusername);
  private:
  const std::string& _internal_recipientusername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recipientusername(const std::string& value);
  std::string* _internal_mutable_recipientusername();
  public:

  // string msgContent = 3;
  void clear_msgcontent();
  const std::string& msgcontent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msgcontent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msgcontent();
  PROTOBUF_NODISCARD std::string* release_msgcontent();
  void set_allocated_msgcontent(std::string* msgcontent);
  private:
  const std::string& _internal_msgcontent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msgcontent(const std::string& value);
  std::string* _internal_mutable_msgcontent();
  public:

  // @@protoc_insertion_point(class_scope:chatservice.ChatMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr senderusername_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr recipientusername_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msgcontent_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class DeleteAccountMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatservice.DeleteAccountMessage) */ {
 public:
  inline DeleteAccountMessage() : DeleteAccountMessage(nullptr) {}
  ~DeleteAccountMessage() override;
  explicit PROTOBUF_CONSTEXPR DeleteAccountMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteAccountMessage(const DeleteAccountMessage& from);
  DeleteAccountMessage(DeleteAccountMessage&& from) noexcept
    : DeleteAccountMessage() {
    *this = ::std::move(from);
  }

  inline DeleteAccountMessage& operator=(const DeleteAccountMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteAccountMessage& operator=(DeleteAccountMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteAccountMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteAccountMessage* internal_default_instance() {
    return reinterpret_cast<const DeleteAccountMessage*>(
               &_DeleteAccountMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(DeleteAccountMessage& a, DeleteAccountMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteAccountMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteAccountMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteAccountMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteAccountMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteAccountMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteAccountMessage& from) {
    DeleteAccountMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteAccountMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatservice.DeleteAccountMessage";
  }
  protected:
  explicit DeleteAccountMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:chatservice.DeleteAccountMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class DeleteAccountReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatservice.DeleteAccountReply) */ {
 public:
  inline DeleteAccountReply() : DeleteAccountReply(nullptr) {}
  ~DeleteAccountReply() override;
  explicit PROTOBUF_CONSTEXPR DeleteAccountReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteAccountReply(const DeleteAccountReply& from);
  DeleteAccountReply(DeleteAccountReply&& from) noexcept
    : DeleteAccountReply() {
    *this = ::std::move(from);
  }

  inline DeleteAccountReply& operator=(const DeleteAccountReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteAccountReply& operator=(DeleteAccountReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteAccountReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteAccountReply* internal_default_instance() {
    return reinterpret_cast<const DeleteAccountReply*>(
               &_DeleteAccountReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(DeleteAccountReply& a, DeleteAccountReply& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteAccountReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteAccountReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteAccountReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteAccountReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteAccountReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteAccountReply& from) {
    DeleteAccountReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteAccountReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatservice.DeleteAccountReply";
  }
  protected:
  explicit DeleteAccountReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMsgFieldNumber = 2,
    kDeletedAccountFieldNumber = 1,
  };
  // optional string errorMsg = 2;
  bool has_errormsg() const;
  private:
  bool _internal_has_errormsg() const;
  public:
  void clear_errormsg();
  const std::string& errormsg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_errormsg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_errormsg();
  PROTOBUF_NODISCARD std::string* release_errormsg();
  void set_allocated_errormsg(std::string* errormsg);
  private:
  const std::string& _internal_errormsg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errormsg(const std::string& value);
  std::string* _internal_mutable_errormsg();
  public:

  // bool deletedAccount = 1;
  void clear_deletedaccount();
  bool deletedaccount() const;
  void set_deletedaccount(bool value);
  private:
  bool _internal_deletedaccount() const;
  void _internal_set_deletedaccount(bool value);
  public:

  // @@protoc_insertion_point(class_scope:chatservice.DeleteAccountReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errormsg_;
    bool deletedaccount_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class MessagesSeenMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatservice.MessagesSeenMessage) */ {
 public:
  inline MessagesSeenMessage() : MessagesSeenMessage(nullptr) {}
  ~MessagesSeenMessage() override;
  explicit PROTOBUF_CONSTEXPR MessagesSeenMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MessagesSeenMessage(const MessagesSeenMessage& from);
  MessagesSeenMessage(MessagesSeenMessage&& from) noexcept
    : MessagesSeenMessage() {
    *this = ::std::move(from);
  }

  inline MessagesSeenMessage& operator=(const MessagesSeenMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessagesSeenMessage& operator=(MessagesSeenMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MessagesSeenMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const MessagesSeenMessage* internal_default_instance() {
    return reinterpret_cast<const MessagesSeenMessage*>(
               &_MessagesSeenMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(MessagesSeenMessage& a, MessagesSeenMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(MessagesSeenMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessagesSeenMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MessagesSeenMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MessagesSeenMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MessagesSeenMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MessagesSeenMessage& from) {
    MessagesSeenMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessagesSeenMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatservice.MessagesSeenMessage";
  }
  protected:
  explicit MessagesSeenMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessagesSeenFieldNumber = 1,
    kFirstMessageIdxFieldNumber = 2,
  };
  // int32 messagesSeen = 1;
  void clear_messagesseen();
  int32_t messagesseen() const;
  void set_messagesseen(int32_t value);
  private:
  int32_t _internal_messagesseen() const;
  void _internal_set_messagesseen(int32_t value);
  public:

  // int32 firstMessageIdx = 2;
  void clear_firstmessageidx();
  int32_t firstmessageidx() const;
  void set_firstmessageidx(int32_t value);
  private:
  int32_t _internal_firstmessageidx() const;
  void _internal_set_firstmessageidx(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:chatservice.MessagesSeenMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t messagesseen_;
    int32_t firstmessageidx_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class NewMessageReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatservice.NewMessageReply) */ {
 public:
  inline NewMessageReply() : NewMessageReply(nullptr) {}
  ~NewMessageReply() override;
  explicit PROTOBUF_CONSTEXPR NewMessageReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NewMessageReply(const NewMessageReply& from);
  NewMessageReply(NewMessageReply&& from) noexcept
    : NewMessageReply() {
    *this = ::std::move(from);
  }

  inline NewMessageReply& operator=(const NewMessageReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewMessageReply& operator=(NewMessageReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NewMessageReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const NewMessageReply* internal_default_instance() {
    return reinterpret_cast<const NewMessageReply*>(
               &_NewMessageReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(NewMessageReply& a, NewMessageReply& b) {
    a.Swap(&b);
  }
  inline void Swap(NewMessageReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewMessageReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NewMessageReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NewMessageReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NewMessageReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NewMessageReply& from) {
    NewMessageReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewMessageReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatservice.NewMessageReply";
  }
  protected:
  explicit NewMessageReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReceivedFieldNumber = 1,
  };
  // bool received = 1;
  void clear_received();
  bool received() const;
  void set_received(bool value);
  private:
  bool _internal_received() const;
  void _internal_set_received(bool value);
  public:

  // @@protoc_insertion_point(class_scope:chatservice.NewMessageReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool received_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class RefreshRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:chatservice.RefreshRequest) */ {
 public:
  inline RefreshRequest() : RefreshRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR RefreshRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RefreshRequest(const RefreshRequest& from);
  RefreshRequest(RefreshRequest&& from) noexcept
    : RefreshRequest() {
    *this = ::std::move(from);
  }

  inline RefreshRequest& operator=(const RefreshRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RefreshRequest& operator=(RefreshRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RefreshRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RefreshRequest* internal_default_instance() {
    return reinterpret_cast<const RefreshRequest*>(
               &_RefreshRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(RefreshRequest& a, RefreshRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RefreshRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RefreshRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RefreshRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RefreshRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RefreshRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RefreshRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatservice.RefreshRequest";
  }
  protected:
  explicit RefreshRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:chatservice.RefreshRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_chatService_2eproto;
};
// -------------------------------------------------------------------

class RefreshResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chatservice.RefreshResponse) */ {
 public:
  inline RefreshResponse() : RefreshResponse(nullptr) {}
  ~RefreshResponse() override;
  explicit PROTOBUF_CONSTEXPR RefreshResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RefreshResponse(const RefreshResponse& from);
  RefreshResponse(RefreshResponse&& from) noexcept
    : RefreshResponse() {
    *this = ::std::move(from);
  }

  inline RefreshResponse& operator=(const RefreshResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RefreshResponse& operator=(RefreshResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RefreshResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RefreshResponse* internal_default_instance() {
    return reinterpret_cast<const RefreshResponse*>(
               &_RefreshResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(RefreshResponse& a, RefreshResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RefreshResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RefreshResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RefreshResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RefreshResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RefreshResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RefreshResponse& from) {
    RefreshResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RefreshResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chatservice.RefreshResponse";
  }
  protected:
  explicit RefreshResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNotificationsFieldNumber = 2,
    kForceLogoutFieldNumber = 1,
  };
  // repeated .chatservice.Notification notifications = 2;
  int notifications_size() const;
  private:
  int _internal_notifications_size() const;
  public:
  void clear_notifications();
  ::chatservice::Notification* mutable_notifications(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chatservice::Notification >*
      mutable_notifications();
  private:
  const ::chatservice::Notification& _internal_notifications(int index) const;
  ::chatservice::Notification* _internal_add_notifications();
  public:
  const ::chatservice::Notification& notifications(int index) const;
  ::chatservice::Notification* add_notifications();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chatservice::Notification >&
      notifications() const;

  // bool forceLogout = 1;
  void clear_forcelogout();
  bool forcelogout() const;
  void set_forcelogout(bool value);
  private:
  bool _internal_forcelogout() const;
  void _internal_set_forcelogout(bool value);
  public:

  // @@protoc_insertion_point(class_scope:chatservice.RefreshResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chatservice::Notification > notifications_;
    bool forcelogout_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chatService_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CreateAccountMessage

// string username = 1;
inline void CreateAccountMessage::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& CreateAccountMessage::username() const {
  // @@protoc_insertion_point(field_get:chatservice.CreateAccountMessage.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateAccountMessage::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.CreateAccountMessage.username)
}
inline std::string* CreateAccountMessage::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:chatservice.CreateAccountMessage.username)
  return _s;
}
inline const std::string& CreateAccountMessage::_internal_username() const {
  return _impl_.username_.Get();
}
inline void CreateAccountMessage::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateAccountMessage::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateAccountMessage::release_username() {
  // @@protoc_insertion_point(field_release:chatservice.CreateAccountMessage.username)
  return _impl_.username_.Release();
}
inline void CreateAccountMessage::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.CreateAccountMessage.username)
}

// string password = 2;
inline void CreateAccountMessage::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& CreateAccountMessage::password() const {
  // @@protoc_insertion_point(field_get:chatservice.CreateAccountMessage.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateAccountMessage::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.CreateAccountMessage.password)
}
inline std::string* CreateAccountMessage::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:chatservice.CreateAccountMessage.password)
  return _s;
}
inline const std::string& CreateAccountMessage::_internal_password() const {
  return _impl_.password_.Get();
}
inline void CreateAccountMessage::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateAccountMessage::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateAccountMessage::release_password() {
  // @@protoc_insertion_point(field_release:chatservice.CreateAccountMessage.password)
  return _impl_.password_.Release();
}
inline void CreateAccountMessage::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.CreateAccountMessage.password)
}

// -------------------------------------------------------------------

// CreateAccountReply

// bool createAccountSuccess = 1;
inline void CreateAccountReply::clear_createaccountsuccess() {
  _impl_.createaccountsuccess_ = false;
}
inline bool CreateAccountReply::_internal_createaccountsuccess() const {
  return _impl_.createaccountsuccess_;
}
inline bool CreateAccountReply::createaccountsuccess() const {
  // @@protoc_insertion_point(field_get:chatservice.CreateAccountReply.createAccountSuccess)
  return _internal_createaccountsuccess();
}
inline void CreateAccountReply::_internal_set_createaccountsuccess(bool value) {
  
  _impl_.createaccountsuccess_ = value;
}
inline void CreateAccountReply::set_createaccountsuccess(bool value) {
  _internal_set_createaccountsuccess(value);
  // @@protoc_insertion_point(field_set:chatservice.CreateAccountReply.createAccountSuccess)
}

// optional string errorMsg = 2;
inline bool CreateAccountReply::_internal_has_errormsg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CreateAccountReply::has_errormsg() const {
  return _internal_has_errormsg();
}
inline void CreateAccountReply::clear_errormsg() {
  _impl_.errormsg_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CreateAccountReply::errormsg() const {
  // @@protoc_insertion_point(field_get:chatservice.CreateAccountReply.errorMsg)
  return _internal_errormsg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateAccountReply::set_errormsg(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.errormsg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.CreateAccountReply.errorMsg)
}
inline std::string* CreateAccountReply::mutable_errormsg() {
  std::string* _s = _internal_mutable_errormsg();
  // @@protoc_insertion_point(field_mutable:chatservice.CreateAccountReply.errorMsg)
  return _s;
}
inline const std::string& CreateAccountReply::_internal_errormsg() const {
  return _impl_.errormsg_.Get();
}
inline void CreateAccountReply::_internal_set_errormsg(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.errormsg_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateAccountReply::_internal_mutable_errormsg() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.errormsg_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateAccountReply::release_errormsg() {
  // @@protoc_insertion_point(field_release:chatservice.CreateAccountReply.errorMsg)
  if (!_internal_has_errormsg()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.errormsg_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.errormsg_.IsDefault()) {
    _impl_.errormsg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CreateAccountReply::set_allocated_errormsg(std::string* errormsg) {
  if (errormsg != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.errormsg_.SetAllocated(errormsg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.errormsg_.IsDefault()) {
    _impl_.errormsg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.CreateAccountReply.errorMsg)
}

// -------------------------------------------------------------------

// LoginMessage

// string username = 1;
inline void LoginMessage::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& LoginMessage::username() const {
  // @@protoc_insertion_point(field_get:chatservice.LoginMessage.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginMessage::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.LoginMessage.username)
}
inline std::string* LoginMessage::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:chatservice.LoginMessage.username)
  return _s;
}
inline const std::string& LoginMessage::_internal_username() const {
  return _impl_.username_.Get();
}
inline void LoginMessage::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginMessage::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginMessage::release_username() {
  // @@protoc_insertion_point(field_release:chatservice.LoginMessage.username)
  return _impl_.username_.Release();
}
inline void LoginMessage::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.LoginMessage.username)
}

// string password = 2;
inline void LoginMessage::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& LoginMessage::password() const {
  // @@protoc_insertion_point(field_get:chatservice.LoginMessage.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginMessage::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.LoginMessage.password)
}
inline std::string* LoginMessage::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:chatservice.LoginMessage.password)
  return _s;
}
inline const std::string& LoginMessage::_internal_password() const {
  return _impl_.password_.Get();
}
inline void LoginMessage::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginMessage::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginMessage::release_password() {
  // @@protoc_insertion_point(field_release:chatservice.LoginMessage.password)
  return _impl_.password_.Release();
}
inline void LoginMessage::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.LoginMessage.password)
}

// -------------------------------------------------------------------

// LoginReply

// bool loginSuccess = 1;
inline void LoginReply::clear_loginsuccess() {
  _impl_.loginsuccess_ = false;
}
inline bool LoginReply::_internal_loginsuccess() const {
  return _impl_.loginsuccess_;
}
inline bool LoginReply::loginsuccess() const {
  // @@protoc_insertion_point(field_get:chatservice.LoginReply.loginSuccess)
  return _internal_loginsuccess();
}
inline void LoginReply::_internal_set_loginsuccess(bool value) {
  
  _impl_.loginsuccess_ = value;
}
inline void LoginReply::set_loginsuccess(bool value) {
  _internal_set_loginsuccess(value);
  // @@protoc_insertion_point(field_set:chatservice.LoginReply.loginSuccess)
}

// optional string errorMsg = 2;
inline bool LoginReply::_internal_has_errormsg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LoginReply::has_errormsg() const {
  return _internal_has_errormsg();
}
inline void LoginReply::clear_errormsg() {
  _impl_.errormsg_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LoginReply::errormsg() const {
  // @@protoc_insertion_point(field_get:chatservice.LoginReply.errorMsg)
  return _internal_errormsg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginReply::set_errormsg(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.errormsg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.LoginReply.errorMsg)
}
inline std::string* LoginReply::mutable_errormsg() {
  std::string* _s = _internal_mutable_errormsg();
  // @@protoc_insertion_point(field_mutable:chatservice.LoginReply.errorMsg)
  return _s;
}
inline const std::string& LoginReply::_internal_errormsg() const {
  return _impl_.errormsg_.Get();
}
inline void LoginReply::_internal_set_errormsg(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.errormsg_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginReply::_internal_mutable_errormsg() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.errormsg_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginReply::release_errormsg() {
  // @@protoc_insertion_point(field_release:chatservice.LoginReply.errorMsg)
  if (!_internal_has_errormsg()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.errormsg_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.errormsg_.IsDefault()) {
    _impl_.errormsg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LoginReply::set_allocated_errormsg(std::string* errormsg) {
  if (errormsg != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.errormsg_.SetAllocated(errormsg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.errormsg_.IsDefault()) {
    _impl_.errormsg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.LoginReply.errorMsg)
}

// -------------------------------------------------------------------

// LogoutMessage

// -------------------------------------------------------------------

// LogoutReply

// optional string errorMsg = 2;
inline bool LogoutReply::_internal_has_errormsg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LogoutReply::has_errormsg() const {
  return _internal_has_errormsg();
}
inline void LogoutReply::clear_errormsg() {
  _impl_.errormsg_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LogoutReply::errormsg() const {
  // @@protoc_insertion_point(field_get:chatservice.LogoutReply.errorMsg)
  return _internal_errormsg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogoutReply::set_errormsg(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.errormsg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.LogoutReply.errorMsg)
}
inline std::string* LogoutReply::mutable_errormsg() {
  std::string* _s = _internal_mutable_errormsg();
  // @@protoc_insertion_point(field_mutable:chatservice.LogoutReply.errorMsg)
  return _s;
}
inline const std::string& LogoutReply::_internal_errormsg() const {
  return _impl_.errormsg_.Get();
}
inline void LogoutReply::_internal_set_errormsg(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.errormsg_.Set(value, GetArenaForAllocation());
}
inline std::string* LogoutReply::_internal_mutable_errormsg() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.errormsg_.Mutable(GetArenaForAllocation());
}
inline std::string* LogoutReply::release_errormsg() {
  // @@protoc_insertion_point(field_release:chatservice.LogoutReply.errorMsg)
  if (!_internal_has_errormsg()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.errormsg_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.errormsg_.IsDefault()) {
    _impl_.errormsg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LogoutReply::set_allocated_errormsg(std::string* errormsg) {
  if (errormsg != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.errormsg_.SetAllocated(errormsg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.errormsg_.IsDefault()) {
    _impl_.errormsg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.LogoutReply.errorMsg)
}

// -------------------------------------------------------------------

// QueryUsersMessage

// optional string username = 1;
inline bool QueryUsersMessage::_internal_has_username() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool QueryUsersMessage::has_username() const {
  return _internal_has_username();
}
inline void QueryUsersMessage::clear_username() {
  _impl_.username_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& QueryUsersMessage::username() const {
  // @@protoc_insertion_point(field_get:chatservice.QueryUsersMessage.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryUsersMessage::set_username(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.QueryUsersMessage.username)
}
inline std::string* QueryUsersMessage::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:chatservice.QueryUsersMessage.username)
  return _s;
}
inline const std::string& QueryUsersMessage::_internal_username() const {
  return _impl_.username_.Get();
}
inline void QueryUsersMessage::_internal_set_username(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryUsersMessage::_internal_mutable_username() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* QueryUsersMessage::release_username() {
  // @@protoc_insertion_point(field_release:chatservice.QueryUsersMessage.username)
  if (!_internal_has_username()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.username_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void QueryUsersMessage::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.QueryUsersMessage.username)
}

// -------------------------------------------------------------------

// User

// string username = 1;
inline void User::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& User::username() const {
  // @@protoc_insertion_point(field_get:chatservice.User.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.User.username)
}
inline std::string* User::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:chatservice.User.username)
  return _s;
}
inline const std::string& User::_internal_username() const {
  return _impl_.username_.Get();
}
inline void User::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_username() {
  // @@protoc_insertion_point(field_release:chatservice.User.username)
  return _impl_.username_.Release();
}
inline void User::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.User.username)
}

// -------------------------------------------------------------------

// SendMessageReply

// bool messageSent = 1;
inline void SendMessageReply::clear_messagesent() {
  _impl_.messagesent_ = false;
}
inline bool SendMessageReply::_internal_messagesent() const {
  return _impl_.messagesent_;
}
inline bool SendMessageReply::messagesent() const {
  // @@protoc_insertion_point(field_get:chatservice.SendMessageReply.messageSent)
  return _internal_messagesent();
}
inline void SendMessageReply::_internal_set_messagesent(bool value) {
  
  _impl_.messagesent_ = value;
}
inline void SendMessageReply::set_messagesent(bool value) {
  _internal_set_messagesent(value);
  // @@protoc_insertion_point(field_set:chatservice.SendMessageReply.messageSent)
}

// optional string errorMsg = 2;
inline bool SendMessageReply::_internal_has_errormsg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SendMessageReply::has_errormsg() const {
  return _internal_has_errormsg();
}
inline void SendMessageReply::clear_errormsg() {
  _impl_.errormsg_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SendMessageReply::errormsg() const {
  // @@protoc_insertion_point(field_get:chatservice.SendMessageReply.errorMsg)
  return _internal_errormsg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendMessageReply::set_errormsg(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.errormsg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.SendMessageReply.errorMsg)
}
inline std::string* SendMessageReply::mutable_errormsg() {
  std::string* _s = _internal_mutable_errormsg();
  // @@protoc_insertion_point(field_mutable:chatservice.SendMessageReply.errorMsg)
  return _s;
}
inline const std::string& SendMessageReply::_internal_errormsg() const {
  return _impl_.errormsg_.Get();
}
inline void SendMessageReply::_internal_set_errormsg(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.errormsg_.Set(value, GetArenaForAllocation());
}
inline std::string* SendMessageReply::_internal_mutable_errormsg() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.errormsg_.Mutable(GetArenaForAllocation());
}
inline std::string* SendMessageReply::release_errormsg() {
  // @@protoc_insertion_point(field_release:chatservice.SendMessageReply.errorMsg)
  if (!_internal_has_errormsg()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.errormsg_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.errormsg_.IsDefault()) {
    _impl_.errormsg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SendMessageReply::set_allocated_errormsg(std::string* errormsg) {
  if (errormsg != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.errormsg_.SetAllocated(errormsg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.errormsg_.IsDefault()) {
    _impl_.errormsg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.SendMessageReply.errorMsg)
}

// -------------------------------------------------------------------

// QueryNotificationsMessage

// string user = 1;
inline void QueryNotificationsMessage::clear_user() {
  _impl_.user_.ClearToEmpty();
}
inline const std::string& QueryNotificationsMessage::user() const {
  // @@protoc_insertion_point(field_get:chatservice.QueryNotificationsMessage.user)
  return _internal_user();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryNotificationsMessage::set_user(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.QueryNotificationsMessage.user)
}
inline std::string* QueryNotificationsMessage::mutable_user() {
  std::string* _s = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:chatservice.QueryNotificationsMessage.user)
  return _s;
}
inline const std::string& QueryNotificationsMessage::_internal_user() const {
  return _impl_.user_.Get();
}
inline void QueryNotificationsMessage::_internal_set_user(const std::string& value) {
  
  _impl_.user_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryNotificationsMessage::_internal_mutable_user() {
  
  return _impl_.user_.Mutable(GetArenaForAllocation());
}
inline std::string* QueryNotificationsMessage::release_user() {
  // @@protoc_insertion_point(field_release:chatservice.QueryNotificationsMessage.user)
  return _impl_.user_.Release();
}
inline void QueryNotificationsMessage::set_allocated_user(std::string* user) {
  if (user != nullptr) {
    
  } else {
    
  }
  _impl_.user_.SetAllocated(user, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_.IsDefault()) {
    _impl_.user_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.QueryNotificationsMessage.user)
}

// -------------------------------------------------------------------

// Notification

// string user = 1;
inline void Notification::clear_user() {
  _impl_.user_.ClearToEmpty();
}
inline const std::string& Notification::user() const {
  // @@protoc_insertion_point(field_get:chatservice.Notification.user)
  return _internal_user();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Notification::set_user(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.Notification.user)
}
inline std::string* Notification::mutable_user() {
  std::string* _s = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:chatservice.Notification.user)
  return _s;
}
inline const std::string& Notification::_internal_user() const {
  return _impl_.user_.Get();
}
inline void Notification::_internal_set_user(const std::string& value) {
  
  _impl_.user_.Set(value, GetArenaForAllocation());
}
inline std::string* Notification::_internal_mutable_user() {
  
  return _impl_.user_.Mutable(GetArenaForAllocation());
}
inline std::string* Notification::release_user() {
  // @@protoc_insertion_point(field_release:chatservice.Notification.user)
  return _impl_.user_.Release();
}
inline void Notification::set_allocated_user(std::string* user) {
  if (user != nullptr) {
    
  } else {
    
  }
  _impl_.user_.SetAllocated(user, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_.IsDefault()) {
    _impl_.user_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.Notification.user)
}

// int32 numberOfNotifications = 2;
inline void Notification::clear_numberofnotifications() {
  _impl_.numberofnotifications_ = 0;
}
inline int32_t Notification::_internal_numberofnotifications() const {
  return _impl_.numberofnotifications_;
}
inline int32_t Notification::numberofnotifications() const {
  // @@protoc_insertion_point(field_get:chatservice.Notification.numberOfNotifications)
  return _internal_numberofnotifications();
}
inline void Notification::_internal_set_numberofnotifications(int32_t value) {
  
  _impl_.numberofnotifications_ = value;
}
inline void Notification::set_numberofnotifications(int32_t value) {
  _internal_set_numberofnotifications(value);
  // @@protoc_insertion_point(field_set:chatservice.Notification.numberOfNotifications)
}

// -------------------------------------------------------------------

// QueryMessagesMessage

// string clientUsername = 1;
inline void QueryMessagesMessage::clear_clientusername() {
  _impl_.clientusername_.ClearToEmpty();
}
inline const std::string& QueryMessagesMessage::clientusername() const {
  // @@protoc_insertion_point(field_get:chatservice.QueryMessagesMessage.clientUsername)
  return _internal_clientusername();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryMessagesMessage::set_clientusername(ArgT0&& arg0, ArgT... args) {
 
 _impl_.clientusername_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.QueryMessagesMessage.clientUsername)
}
inline std::string* QueryMessagesMessage::mutable_clientusername() {
  std::string* _s = _internal_mutable_clientusername();
  // @@protoc_insertion_point(field_mutable:chatservice.QueryMessagesMessage.clientUsername)
  return _s;
}
inline const std::string& QueryMessagesMessage::_internal_clientusername() const {
  return _impl_.clientusername_.Get();
}
inline void QueryMessagesMessage::_internal_set_clientusername(const std::string& value) {
  
  _impl_.clientusername_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryMessagesMessage::_internal_mutable_clientusername() {
  
  return _impl_.clientusername_.Mutable(GetArenaForAllocation());
}
inline std::string* QueryMessagesMessage::release_clientusername() {
  // @@protoc_insertion_point(field_release:chatservice.QueryMessagesMessage.clientUsername)
  return _impl_.clientusername_.Release();
}
inline void QueryMessagesMessage::set_allocated_clientusername(std::string* clientusername) {
  if (clientusername != nullptr) {
    
  } else {
    
  }
  _impl_.clientusername_.SetAllocated(clientusername, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clientusername_.IsDefault()) {
    _impl_.clientusername_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.QueryMessagesMessage.clientUsername)
}

// string otherUsername = 2;
inline void QueryMessagesMessage::clear_otherusername() {
  _impl_.otherusername_.ClearToEmpty();
}
inline const std::string& QueryMessagesMessage::otherusername() const {
  // @@protoc_insertion_point(field_get:chatservice.QueryMessagesMessage.otherUsername)
  return _internal_otherusername();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryMessagesMessage::set_otherusername(ArgT0&& arg0, ArgT... args) {
 
 _impl_.otherusername_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.QueryMessagesMessage.otherUsername)
}
inline std::string* QueryMessagesMessage::mutable_otherusername() {
  std::string* _s = _internal_mutable_otherusername();
  // @@protoc_insertion_point(field_mutable:chatservice.QueryMessagesMessage.otherUsername)
  return _s;
}
inline const std::string& QueryMessagesMessage::_internal_otherusername() const {
  return _impl_.otherusername_.Get();
}
inline void QueryMessagesMessage::_internal_set_otherusername(const std::string& value) {
  
  _impl_.otherusername_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryMessagesMessage::_internal_mutable_otherusername() {
  
  return _impl_.otherusername_.Mutable(GetArenaForAllocation());
}
inline std::string* QueryMessagesMessage::release_otherusername() {
  // @@protoc_insertion_point(field_release:chatservice.QueryMessagesMessage.otherUsername)
  return _impl_.otherusername_.Release();
}
inline void QueryMessagesMessage::set_allocated_otherusername(std::string* otherusername) {
  if (otherusername != nullptr) {
    
  } else {
    
  }
  _impl_.otherusername_.SetAllocated(otherusername, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.otherusername_.IsDefault()) {
    _impl_.otherusername_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.QueryMessagesMessage.otherUsername)
}

// -------------------------------------------------------------------

// ChatMessage

// string senderUsername = 1;
inline void ChatMessage::clear_senderusername() {
  _impl_.senderusername_.ClearToEmpty();
}
inline const std::string& ChatMessage::senderusername() const {
  // @@protoc_insertion_point(field_get:chatservice.ChatMessage.senderUsername)
  return _internal_senderusername();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatMessage::set_senderusername(ArgT0&& arg0, ArgT... args) {
 
 _impl_.senderusername_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.ChatMessage.senderUsername)
}
inline std::string* ChatMessage::mutable_senderusername() {
  std::string* _s = _internal_mutable_senderusername();
  // @@protoc_insertion_point(field_mutable:chatservice.ChatMessage.senderUsername)
  return _s;
}
inline const std::string& ChatMessage::_internal_senderusername() const {
  return _impl_.senderusername_.Get();
}
inline void ChatMessage::_internal_set_senderusername(const std::string& value) {
  
  _impl_.senderusername_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatMessage::_internal_mutable_senderusername() {
  
  return _impl_.senderusername_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatMessage::release_senderusername() {
  // @@protoc_insertion_point(field_release:chatservice.ChatMessage.senderUsername)
  return _impl_.senderusername_.Release();
}
inline void ChatMessage::set_allocated_senderusername(std::string* senderusername) {
  if (senderusername != nullptr) {
    
  } else {
    
  }
  _impl_.senderusername_.SetAllocated(senderusername, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.senderusername_.IsDefault()) {
    _impl_.senderusername_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.ChatMessage.senderUsername)
}

// string recipientUsername = 2;
inline void ChatMessage::clear_recipientusername() {
  _impl_.recipientusername_.ClearToEmpty();
}
inline const std::string& ChatMessage::recipientusername() const {
  // @@protoc_insertion_point(field_get:chatservice.ChatMessage.recipientUsername)
  return _internal_recipientusername();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatMessage::set_recipientusername(ArgT0&& arg0, ArgT... args) {
 
 _impl_.recipientusername_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.ChatMessage.recipientUsername)
}
inline std::string* ChatMessage::mutable_recipientusername() {
  std::string* _s = _internal_mutable_recipientusername();
  // @@protoc_insertion_point(field_mutable:chatservice.ChatMessage.recipientUsername)
  return _s;
}
inline const std::string& ChatMessage::_internal_recipientusername() const {
  return _impl_.recipientusername_.Get();
}
inline void ChatMessage::_internal_set_recipientusername(const std::string& value) {
  
  _impl_.recipientusername_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatMessage::_internal_mutable_recipientusername() {
  
  return _impl_.recipientusername_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatMessage::release_recipientusername() {
  // @@protoc_insertion_point(field_release:chatservice.ChatMessage.recipientUsername)
  return _impl_.recipientusername_.Release();
}
inline void ChatMessage::set_allocated_recipientusername(std::string* recipientusername) {
  if (recipientusername != nullptr) {
    
  } else {
    
  }
  _impl_.recipientusername_.SetAllocated(recipientusername, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.recipientusername_.IsDefault()) {
    _impl_.recipientusername_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.ChatMessage.recipientUsername)
}

// string msgContent = 3;
inline void ChatMessage::clear_msgcontent() {
  _impl_.msgcontent_.ClearToEmpty();
}
inline const std::string& ChatMessage::msgcontent() const {
  // @@protoc_insertion_point(field_get:chatservice.ChatMessage.msgContent)
  return _internal_msgcontent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatMessage::set_msgcontent(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msgcontent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.ChatMessage.msgContent)
}
inline std::string* ChatMessage::mutable_msgcontent() {
  std::string* _s = _internal_mutable_msgcontent();
  // @@protoc_insertion_point(field_mutable:chatservice.ChatMessage.msgContent)
  return _s;
}
inline const std::string& ChatMessage::_internal_msgcontent() const {
  return _impl_.msgcontent_.Get();
}
inline void ChatMessage::_internal_set_msgcontent(const std::string& value) {
  
  _impl_.msgcontent_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatMessage::_internal_mutable_msgcontent() {
  
  return _impl_.msgcontent_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatMessage::release_msgcontent() {
  // @@protoc_insertion_point(field_release:chatservice.ChatMessage.msgContent)
  return _impl_.msgcontent_.Release();
}
inline void ChatMessage::set_allocated_msgcontent(std::string* msgcontent) {
  if (msgcontent != nullptr) {
    
  } else {
    
  }
  _impl_.msgcontent_.SetAllocated(msgcontent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msgcontent_.IsDefault()) {
    _impl_.msgcontent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.ChatMessage.msgContent)
}

// -------------------------------------------------------------------

// DeleteAccountMessage

// string username = 1;
inline void DeleteAccountMessage::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& DeleteAccountMessage::username() const {
  // @@protoc_insertion_point(field_get:chatservice.DeleteAccountMessage.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteAccountMessage::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.DeleteAccountMessage.username)
}
inline std::string* DeleteAccountMessage::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:chatservice.DeleteAccountMessage.username)
  return _s;
}
inline const std::string& DeleteAccountMessage::_internal_username() const {
  return _impl_.username_.Get();
}
inline void DeleteAccountMessage::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteAccountMessage::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteAccountMessage::release_username() {
  // @@protoc_insertion_point(field_release:chatservice.DeleteAccountMessage.username)
  return _impl_.username_.Release();
}
inline void DeleteAccountMessage::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.DeleteAccountMessage.username)
}

// string password = 2;
inline void DeleteAccountMessage::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& DeleteAccountMessage::password() const {
  // @@protoc_insertion_point(field_get:chatservice.DeleteAccountMessage.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteAccountMessage::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.DeleteAccountMessage.password)
}
inline std::string* DeleteAccountMessage::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:chatservice.DeleteAccountMessage.password)
  return _s;
}
inline const std::string& DeleteAccountMessage::_internal_password() const {
  return _impl_.password_.Get();
}
inline void DeleteAccountMessage::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteAccountMessage::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteAccountMessage::release_password() {
  // @@protoc_insertion_point(field_release:chatservice.DeleteAccountMessage.password)
  return _impl_.password_.Release();
}
inline void DeleteAccountMessage::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.DeleteAccountMessage.password)
}

// -------------------------------------------------------------------

// DeleteAccountReply

// bool deletedAccount = 1;
inline void DeleteAccountReply::clear_deletedaccount() {
  _impl_.deletedaccount_ = false;
}
inline bool DeleteAccountReply::_internal_deletedaccount() const {
  return _impl_.deletedaccount_;
}
inline bool DeleteAccountReply::deletedaccount() const {
  // @@protoc_insertion_point(field_get:chatservice.DeleteAccountReply.deletedAccount)
  return _internal_deletedaccount();
}
inline void DeleteAccountReply::_internal_set_deletedaccount(bool value) {
  
  _impl_.deletedaccount_ = value;
}
inline void DeleteAccountReply::set_deletedaccount(bool value) {
  _internal_set_deletedaccount(value);
  // @@protoc_insertion_point(field_set:chatservice.DeleteAccountReply.deletedAccount)
}

// optional string errorMsg = 2;
inline bool DeleteAccountReply::_internal_has_errormsg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeleteAccountReply::has_errormsg() const {
  return _internal_has_errormsg();
}
inline void DeleteAccountReply::clear_errormsg() {
  _impl_.errormsg_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeleteAccountReply::errormsg() const {
  // @@protoc_insertion_point(field_get:chatservice.DeleteAccountReply.errorMsg)
  return _internal_errormsg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteAccountReply::set_errormsg(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.errormsg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chatservice.DeleteAccountReply.errorMsg)
}
inline std::string* DeleteAccountReply::mutable_errormsg() {
  std::string* _s = _internal_mutable_errormsg();
  // @@protoc_insertion_point(field_mutable:chatservice.DeleteAccountReply.errorMsg)
  return _s;
}
inline const std::string& DeleteAccountReply::_internal_errormsg() const {
  return _impl_.errormsg_.Get();
}
inline void DeleteAccountReply::_internal_set_errormsg(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.errormsg_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteAccountReply::_internal_mutable_errormsg() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.errormsg_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteAccountReply::release_errormsg() {
  // @@protoc_insertion_point(field_release:chatservice.DeleteAccountReply.errorMsg)
  if (!_internal_has_errormsg()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.errormsg_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.errormsg_.IsDefault()) {
    _impl_.errormsg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DeleteAccountReply::set_allocated_errormsg(std::string* errormsg) {
  if (errormsg != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.errormsg_.SetAllocated(errormsg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.errormsg_.IsDefault()) {
    _impl_.errormsg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chatservice.DeleteAccountReply.errorMsg)
}

// -------------------------------------------------------------------

// MessagesSeenMessage

// int32 messagesSeen = 1;
inline void MessagesSeenMessage::clear_messagesseen() {
  _impl_.messagesseen_ = 0;
}
inline int32_t MessagesSeenMessage::_internal_messagesseen() const {
  return _impl_.messagesseen_;
}
inline int32_t MessagesSeenMessage::messagesseen() const {
  // @@protoc_insertion_point(field_get:chatservice.MessagesSeenMessage.messagesSeen)
  return _internal_messagesseen();
}
inline void MessagesSeenMessage::_internal_set_messagesseen(int32_t value) {
  
  _impl_.messagesseen_ = value;
}
inline void MessagesSeenMessage::set_messagesseen(int32_t value) {
  _internal_set_messagesseen(value);
  // @@protoc_insertion_point(field_set:chatservice.MessagesSeenMessage.messagesSeen)
}

// int32 firstMessageIdx = 2;
inline void MessagesSeenMessage::clear_firstmessageidx() {
  _impl_.firstmessageidx_ = 0;
}
inline int32_t MessagesSeenMessage::_internal_firstmessageidx() const {
  return _impl_.firstmessageidx_;
}
inline int32_t MessagesSeenMessage::firstmessageidx() const {
  // @@protoc_insertion_point(field_get:chatservice.MessagesSeenMessage.firstMessageIdx)
  return _internal_firstmessageidx();
}
inline void MessagesSeenMessage::_internal_set_firstmessageidx(int32_t value) {
  
  _impl_.firstmessageidx_ = value;
}
inline void MessagesSeenMessage::set_firstmessageidx(int32_t value) {
  _internal_set_firstmessageidx(value);
  // @@protoc_insertion_point(field_set:chatservice.MessagesSeenMessage.firstMessageIdx)
}

// -------------------------------------------------------------------

// NewMessageReply

// bool received = 1;
inline void NewMessageReply::clear_received() {
  _impl_.received_ = false;
}
inline bool NewMessageReply::_internal_received() const {
  return _impl_.received_;
}
inline bool NewMessageReply::received() const {
  // @@protoc_insertion_point(field_get:chatservice.NewMessageReply.received)
  return _internal_received();
}
inline void NewMessageReply::_internal_set_received(bool value) {
  
  _impl_.received_ = value;
}
inline void NewMessageReply::set_received(bool value) {
  _internal_set_received(value);
  // @@protoc_insertion_point(field_set:chatservice.NewMessageReply.received)
}

// -------------------------------------------------------------------

// RefreshRequest

// -------------------------------------------------------------------

// RefreshResponse

// bool forceLogout = 1;
inline void RefreshResponse::clear_forcelogout() {
  _impl_.forcelogout_ = false;
}
inline bool RefreshResponse::_internal_forcelogout() const {
  return _impl_.forcelogout_;
}
inline bool RefreshResponse::forcelogout() const {
  // @@protoc_insertion_point(field_get:chatservice.RefreshResponse.forceLogout)
  return _internal_forcelogout();
}
inline void RefreshResponse::_internal_set_forcelogout(bool value) {
  
  _impl_.forcelogout_ = value;
}
inline void RefreshResponse::set_forcelogout(bool value) {
  _internal_set_forcelogout(value);
  // @@protoc_insertion_point(field_set:chatservice.RefreshResponse.forceLogout)
}

// repeated .chatservice.Notification notifications = 2;
inline int RefreshResponse::_internal_notifications_size() const {
  return _impl_.notifications_.size();
}
inline int RefreshResponse::notifications_size() const {
  return _internal_notifications_size();
}
inline void RefreshResponse::clear_notifications() {
  _impl_.notifications_.Clear();
}
inline ::chatservice::Notification* RefreshResponse::mutable_notifications(int index) {
  // @@protoc_insertion_point(field_mutable:chatservice.RefreshResponse.notifications)
  return _impl_.notifications_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chatservice::Notification >*
RefreshResponse::mutable_notifications() {
  // @@protoc_insertion_point(field_mutable_list:chatservice.RefreshResponse.notifications)
  return &_impl_.notifications_;
}
inline const ::chatservice::Notification& RefreshResponse::_internal_notifications(int index) const {
  return _impl_.notifications_.Get(index);
}
inline const ::chatservice::Notification& RefreshResponse::notifications(int index) const {
  // @@protoc_insertion_point(field_get:chatservice.RefreshResponse.notifications)
  return _internal_notifications(index);
}
inline ::chatservice::Notification* RefreshResponse::_internal_add_notifications() {
  return _impl_.notifications_.Add();
}
inline ::chatservice::Notification* RefreshResponse::add_notifications() {
  ::chatservice::Notification* _add = _internal_add_notifications();
  // @@protoc_insertion_point(field_add:chatservice.RefreshResponse.notifications)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chatservice::Notification >&
RefreshResponse::notifications() const {
  // @@protoc_insertion_point(field_list:chatservice.RefreshResponse.notifications)
  return _impl_.notifications_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace chatservice

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_chatService_2eproto
